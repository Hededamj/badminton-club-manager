// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Club model for multi-tenancy
model Club {
  id              String    @id @default(uuid())
  name            String    @db.VarChar(255)
  slug            String    @unique @db.VarChar(100)
  description     String?   @db.Text
  logo            String?   @db.Text
  settings        Json?
  holdsportTeamId String?   @unique @map("holdsport_team_id")
  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  memberships     ClubMembership[]
  players         Player[]
  trainings       Training[]
  tournaments     Tournament[]
  invitations     ClubInvitation[]

  @@index([slug])
  @@index([isActive])
  @@map("clubs")
}

// Club membership (User <-> Club with role)
model ClubMembership {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  clubId    String    @map("club_id")
  role      ClubRole  @default(MEMBER)
  playerId  String?   @unique @map("player_id")
  isActive  Boolean   @default(true) @map("is_active")
  joinedAt  DateTime  @default(now()) @map("joined_at")
  updatedAt DateTime  @updatedAt @map("updated_at")

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  club      Club      @relation(fields: [clubId], references: [id], onDelete: Cascade)
  player    Player?   @relation(fields: [playerId], references: [id], onDelete: SetNull)

  @@unique([userId, clubId])
  @@index([userId])
  @@index([clubId])
  @@index([playerId])
  @@map("club_memberships")
}

// Club invitation
model ClubInvitation {
  id         String    @id @default(uuid())
  clubId     String    @map("club_id")
  email      String    @db.VarChar(255)
  role       ClubRole  @default(MEMBER)
  token      String    @unique @default(uuid())
  expiresAt  DateTime  @map("expires_at")
  usedAt     DateTime? @map("used_at")
  createdBy  String    @map("created_by")
  createdAt  DateTime  @default(now()) @map("created_at")

  club       Club      @relation(fields: [clubId], references: [id], onDelete: Cascade)
  creator    User      @relation(fields: [createdBy], references: [id])

  @@index([clubId])
  @@index([token])
  @@index([email])
  @@map("club_invitations")
}

// User model for authentication
model User {
  id            String           @id @default(uuid())
  email         String           @unique
  passwordHash  String           @map("password_hash")
  role          UserRole         @default(PLAYER)
  playerId      String?          @unique @map("player_id")
  createdAt     DateTime         @default(now()) @map("created_at")
  updatedAt     DateTime         @updatedAt @map("updated_at")

  player             Player?          @relation(fields: [playerId], references: [id])
  memberships        ClubMembership[]
  createdInvitations ClubInvitation[]

  @@map("users")
}

// Team model (from Holdsport)
model Team {
  id              String    @id @default(uuid())
  name            String    @db.VarChar(255)
  holdsportId     String?   @unique @map("holdsport_id")
  description     String?   @db.Text
  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  teamPlayers     TeamPlayer[]

  @@index([isActive])
  @@map("teams")
}

// Junction table: Team <-> Player
model TeamPlayer {
  id        String   @id @default(uuid())
  teamId    String   @map("team_id")
  playerId  String   @map("player_id")
  createdAt DateTime @default(now()) @map("created_at")

  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  player    Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([teamId, playerId])
  @@index([teamId])
  @@index([playerId])
  @@map("team_players")
}

// Player model
model Player {
  id                String    @id @default(uuid())
  clubId            String?   @map("club_id")  // Will be required after migration
  name              String    @db.VarChar(255)
  email             String?   @db.VarChar(255)
  phone             String?   @db.VarChar(20)
  holdsportId       String?   @map("holdsport_id")
  level             Float     @default(1500) // ELO-style rating
  gender            Gender?   // For mixed doubles
  isActive          Boolean   @default(true) @map("is_active")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  club              Club?     @relation(fields: [clubId], references: [id], onDelete: Cascade)
  membership        ClubMembership?
  user              User?
  teamPlayers       TeamPlayer[]
  trainingPlayers   TrainingPlayer[]
  tournamentPlayers TournamentPlayer[]
  matchPlayers      MatchPlayer[]
  statistics        PlayerStatistics?
  partnershipsAsPlayer1 Partnership[] @relation("Player1Partnerships")
  partnershipsAsPlayer2 Partnership[] @relation("Player2Partnerships")
  oppositionsAsPlayer1  Opposition[]  @relation("Player1Oppositions")
  oppositionsAsPlayer2  Opposition[]  @relation("Player2Oppositions")

  @@unique([clubId, email])
  @@unique([clubId, holdsportId])
  @@index([clubId])
  @@index([level])
  @@index([isActive])
  @@map("players")
}

// Player statistics (aggregated data)
model PlayerStatistics {
  id                    String   @id @default(uuid())
  playerId              String   @unique @map("player_id")
  totalMatches          Int      @default(0) @map("total_matches")
  wins                  Int      @default(0)
  losses                Int      @default(0)
  winRate               Float    @default(0) @map("win_rate")
  currentStreak         Int      @default(0) @map("current_streak")
  longestWinStreak      Int      @default(0) @map("longest_win_streak")
  averagePartnerLevel   Float?   @map("average_partner_level")
  averageOpponentLevel  Float?   @map("average_opponent_level")
  lastUpdated           DateTime @updatedAt @map("last_updated")

  player                Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@map("player_statistics")
}

// Training session
model Training {
  id              String          @id @default(uuid())
  clubId          String?         @map("club_id")  // Will be required after migration
  name            String          @db.VarChar(255)
  date            DateTime        @db.Date
  startTime       DateTime?       @map("start_time")
  endTime         DateTime?       @map("end_time")
  courts          Int             @default(6) // Number of courts available
  matchesPerCourt Int             @default(3) @map("matches_per_court")
  status          TrainingStatus  @default(PLANNED)
  holdsportId     String?         @unique @map("holdsport_id") // ID from Holdsport API for syncing
  createdAt       DateTime        @default(now()) @map("created_at")
  updatedAt       DateTime        @updatedAt @map("updated_at")

  club            Club?           @relation(fields: [clubId], references: [id], onDelete: Cascade)
  trainingPlayers TrainingPlayer[]
  matches         Match[]

  @@index([clubId])
  @@index([date])
  @@index([status])
  @@map("trainings")
}

// Junction table: Training <-> Player
model TrainingPlayer {
  id          String    @id @default(uuid())
  trainingId  String    @map("training_id")
  playerId    String    @map("player_id")
  attending   Boolean   @default(true)
  paused      Boolean   @default(false) // Player paused during training (injury/leaving early)
  pausedAt    DateTime? @map("paused_at") // When player was paused
  createdAt   DateTime  @default(now()) @map("created_at")

  training    Training @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  player      Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([trainingId, playerId])
  @@index([trainingId])
  @@index([playerId])
  @@map("training_players")
}

// Match
model Match {
  id             String      @id @default(uuid())
  trainingId     String?     @map("training_id")
  tournamentId   String?     @map("tournament_id")
  courtNumber    Int         @map("court_number")
  matchNumber    Int         @map("match_number") // Match 1, 2, 3 on each court
  status         MatchStatus @default(PENDING)
  benchedPlayers Json?       @map("benched_players") // Players sitting out, waiting to sub in
  completedAt    DateTime?   @map("completed_at")
  createdAt      DateTime    @default(now()) @map("created_at")

  training     Training?      @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  tournament   Tournament?    @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  matchPlayers MatchPlayer[]
  result       MatchResult?

  @@index([trainingId])
  @@index([tournamentId])
  @@index([courtNumber])
  @@map("matches")
}

// Match player (4 players per match)
model MatchPlayer {
  id       String  @id @default(uuid())
  matchId  String  @map("match_id")
  playerId String  @map("player_id")
  team     Int     // 1 or 2
  position Int     // 1 or 2 (left/right)

  match    Match   @relation(fields: [matchId], references: [id], onDelete: Cascade)
  player   Player  @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([matchId, playerId])
  @@index([matchId])
  @@index([playerId])
  @@map("match_players")
}

// Match result
model MatchResult {
  id            String   @id @default(uuid())
  matchId       String   @unique @map("match_id")
  team1Score    Int      @map("team1_score")  // Number of sets won by team 1
  team2Score    Int      @map("team2_score")  // Number of sets won by team 2
  winningTeam   Int      @map("winning_team") // 1 or 2
  sets          Json?    // Array of set scores: [{team1: 21, team2: 19}, ...]
  levelChange   Json?    @map("level_change") // {playerId: change}
  createdAt     DateTime @default(now()) @map("created_at")

  match         Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@map("match_results")
}

// Partnership history (for variety tracking)
model Partnership {
  id              String   @id @default(uuid())
  player1Id       String   @map("player1_id")
  player2Id       String   @map("player2_id")
  timesPartnered  Int      @default(1) @map("times_partnered")
  wins            Int      @default(0)
  losses          Int      @default(0)
  lastPartnered   DateTime @map("last_partnered")

  player1         Player   @relation("Player1Partnerships", fields: [player1Id], references: [id], onDelete: Cascade)
  player2         Player   @relation("Player2Partnerships", fields: [player2Id], references: [id], onDelete: Cascade)

  @@unique([player1Id, player2Id])
  @@index([player1Id])
  @@index([player2Id])
  @@map("partnerships")
}

// Opposition history (for variety tracking)
model Opposition {
  id            String   @id @default(uuid())
  player1Id     String   @map("player1_id")
  player2Id     String   @map("player2_id")
  timesOpposed  Int      @default(1) @map("times_opposed")
  player1Wins   Int      @default(0) @map("player1_wins")
  player2Wins   Int      @default(0) @map("player2_wins")
  lastOpposed   DateTime @map("last_opposed")

  player1       Player   @relation("Player1Oppositions", fields: [player1Id], references: [id], onDelete: Cascade)
  player2       Player   @relation("Player2Oppositions", fields: [player2Id], references: [id], onDelete: Cascade)

  @@unique([player1Id, player2Id])
  @@index([player1Id])
  @@index([player2Id])
  @@map("oppositions")
}

// Tournament
model Tournament {
  id                String              @id @default(uuid())
  clubId            String?             @map("club_id")  // Will be required after migration
  name              String              @db.VarChar(255)
  startDate         DateTime            @map("start_date") @db.Date
  endDate           DateTime?           @map("end_date") @db.Date
  format            TournamentFormat
  matchTypes        TournamentMatchType[] @default([MENS_DOUBLES, WOMENS_DOUBLES, MIXED_DOUBLES]) @map("match_types")
  status            TournamentStatus    @default(PLANNED)
  description       String?             @db.Text
  createdAt         DateTime            @default(now()) @map("created_at")
  updatedAt         DateTime            @updatedAt @map("updated_at")

  club              Club?               @relation(fields: [clubId], references: [id], onDelete: Cascade)
  matches           Match[]
  tournamentPlayers TournamentPlayer[]

  @@index([clubId])
  @@index([status])
  @@map("tournaments")
}

// Junction table: Tournament <-> Player
model TournamentPlayer {
  id           String     @id @default(uuid())
  tournamentId String     @map("tournament_id")
  playerId     String     @map("player_id")
  createdAt    DateTime   @default(now()) @map("created_at")

  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  player       Player     @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, playerId])
  @@index([tournamentId])
  @@index([playerId])
  @@map("tournament_players")
}

// Enums
enum UserRole {
  ADMIN
  PLAYER
}

enum ClubRole {
  OWNER   // Full control, can delete club
  ADMIN   // Can manage club settings, players, trainings
  MEMBER  // Can view and participate
}

enum TrainingStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum MatchStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum TournamentFormat {
  SINGLE_ELIMINATION
  DOUBLE_ELIMINATION
  ROUND_ROBIN
  SWISS
}

enum TournamentMatchType {
  MENS_DOUBLES      // HD - Herre Double
  WOMENS_DOUBLES    // DD - Dame Double
  MIXED_DOUBLES     // MD - Mix Double
  SINGLES           // Single
}

enum TournamentStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum Gender {
  MALE
  FEMALE
}
